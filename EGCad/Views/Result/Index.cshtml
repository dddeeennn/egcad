@using EGCad.Common.Infrastructure.MVC
@model EGCad.Models.ResultModel
@{
	ViewBag.Title = "Index";
	Layout = "~/Views/Shared/_Layout.cshtml";
}
<h2>Результаты расчета</h2>
<div class="form-horizontal">
	<div class="form-group col-sm-12">
		<canvas id="tip" width=100 height=25></canvas>
		<canvas width="300px" height="300px" id="result-map-container" style="border: 1px solid #ccc">
			Здесь должна быть отображена загруженная карта.
			Для работы с приложением обновите браузер.
			Минимальная поддерживаемая версия браузеров:
			Internet Explorer 10+, 	Google Chrome 38+, FireFox
		</canvas>
	</div>
</div>
@if (Model != null && Model.Map != null)
{
	<script>

		var container = $('#main');
		var imgOffset = 45,
            tipCanvas = document.getElementById('tip'),
            tipCtx = tipCanvas.getContext('2d'),
            pointRadius = 4,
            canvas = $('#result-map-container'),
            startPoint,
            endPoint;

		var ctx = canvas[0].getContext('2d');

		var colors = getColours(@Model.ClusterCount*2);
		var map = @Model.Map.SerializeObject();
		var points = pointAdapter(@Model.Points.SerializeObject());


		initCanvas(map);

		canvas.on('imgLoaded', function() {
			drawPoints(points);
		});

		function drawPoints(points) {
			$.each(points, function(index, value) {
				var color = value.isNew ? "#000" : value.color;
				drawPoint(ctx, value.x, value.y, 4, color);
			});
		}

		function initCanvas(map) {
			var width = map.width;
			var height = map.height;

			var img = new Image(width, height);
			img.src = map.imgSrc;
			img.onload = function() {
				canvas[0].width = width + 2 * imgOffset;
				canvas[0].height = height + 2 * imgOffset;

				ctx.drawImage(img, imgOffset, imgOffset, width, height);

				canvas[0].addEventListener('mousemove',function(e) { handleMouseMove(e, $(this)[0]); },false);

				drawScale(ctx, Math.ceil(width / 10), 10, 15, 30);

				if (map.scaleKoef > 0) drawScaleText(ctx, map.scaleKoef, Math.ceil(width / 10), 10, 15, 30);

				drawFrontLine(ctx, map.start, map.end, map.k);

				canvas.trigger("imgLoaded");
			};
		}

		function drawPoint(context, centerX, centerY, radius, color) {
			context.beginPath();
			context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
			context.fillStyle = color;
			context.fill();
			context.lineWidth = 1;
			context.strokeStyle = '#003300';
			context.stroke();
		}

		function drawScale(ctx, tileLength, tileCount, thickness, offset) {
			for (var i = 0; i < tileCount; i++) {
				if (i % 2 == 0) {
					ctx.fillRect(thickness + offset + tileLength * i, offset, tileLength, thickness);
					ctx.strokeRect(thickness + offset + tileLength * i, offset, tileLength, thickness);
					ctx.fillRect(offset, thickness + offset + tileLength * i, thickness, tileLength);
					ctx.strokeRect(offset, thickness + offset + tileLength * i, thickness, tileLength);
				} else {
					ctx.rect(thickness + offset + tileLength * i, offset, tileLength, thickness);
					ctx.rect(offset, thickness + offset + tileLength * i, thickness, tileLength);
					ctx.stroke();
				}
			}
		}

		function drawScaleText(ctx, scale, tileLength, tileCount, thickness, offset) {
			var scaleText = Math.round(scale * tileLength);
			var alignKoef = thickness + offset; //align scale text
			for (var i = 1; i < tileCount; i++) {
				ctx.fillText(scaleText * (i - 1), alignKoef + tileLength * i, offset * 3 / 4);
				ctx.fillText(scaleText * (i - 1), offset / 6, alignKoef + tileLength * i);
			}
		}

		// show tooltip when mouse hovers over dot
		function handleMouseMove(e, canvas) {

			var x = event.clientX;
			var y = event.clientY;

			x -= canvas.getBoundingClientRect().left;
			y -= canvas.getBoundingClientRect().top;

			if (x.isBetween(imgOffset, canvas.width - imgOffset) &&
				y.isBetween(imgOffset, canvas.height - imgOffset) &&
				points) {
				handleMouseMoveOnPoint(points, x, y);
			}
		}

		function handleMouseMoveOnPoint(dots, mouseX, mouseY) {
			var hit = false;
			for (var i = 0; i < dots.length; i++) {
				var point = dots[i];
				var dx = mouseX - point.x;
				var dy = mouseY - point.y;
				if (dx * dx + dy * dy < point.r * point.r) {
					tipCanvas.style.left = (point.x) + "px";
					tipCanvas.style.top = (point.y - 40) + "px";
					tipCtx.clearRect(0, 0, tipCanvas.width, tipCanvas.height);
					tipCtx.fillText(point.text, 5, 15);
					hit = true;
				}
				if (!hit) {
					tipCanvas.style.left = "-1200px";
				}
			}
		}

		function pointAdapter(points) {
			return $.map(points, function(value) {
				return {
					x:value.x,
					y:value.y,
					text:value.title,
					isNew:value.isNew,
					color:colors[value.clusterIndex],
					r:pointRadius
				};
			});
		}

		function drawFrontLine(ctx,start,end,k) {
			var x1 = start.split(',')[0],
                y1 = start.split(',')[1],
                x2 = end.split(',')[0],
                y2 = end.split(',')[1];

			drawSegment(ctx,x1,y1,x2,y2,k);
		}

		function drawSegment(ctx,x1,y1,x2,y2) {
			drawLine(ctx, x1, y1, x2, y2);
		}

		function drawLine(ctx, x1, y1, x2, y2) {
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
		}

		function componentToHex(c) {
			var hex = c.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}

		function rgbToHex(r, g, b) {
			return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
		}

		function getColours(numberOfColours) {
			var colors = [];
			var i = 360 / (numberOfColours - 1); // distribute the colors evenly on the hue range
			for (var x=0; x<numberOfColours; x++) {
				var color = (hsvToRgb(i * x, 100, 100)); // you can also alternate the saturation and value for even more contrast between the colors
				colors.push(rgbToHex(color[0],color[1],color[2]));
			}
			return colors;
		}

		function hsvToRgb(h,s,v) {
			var r, g, b;
			var i;
			var f, p, q, t;

			// Make sure our arguments stay in-range
			h = Math.max(0, Math.min(360, h));
			s = Math.max(0, Math.min(100, s));
			v = Math.max(0, Math.min(100, v));

			// We accept saturation and value arguments from 0 to 100 because that's
			// how Photoshop represents those values. Internally, however, the
			// saturation and value are calculated from a range of 0 to 1. We make
			// That conversion here.
			s /= 100;
			v /= 100;

			if(s == 0) {
				// Achromatic (grey)
				r = g = b = v;
				return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
			}

			h /= 60; // sector 0 to 5
			i = Math.floor(h);
			f = h - i; // factorial part of h
			p = v * (1 - s);
			q = v * (1 - s * f);
			t = v * (1 - s * (1 - f));

			switch(i) {
				case 0:
					r = v;
					g = t;
					b = p;
					break;

				case 1:
					r = q;
					g = v;
					b = p;
					break;

				case 2:
					r = p;
					g = v;
					b = t;
					break;

				case 3:
					r = p;
					g = q;
					b = v;
					break;

				case 4:
					r = t;
					g = p;
					b = v;
					break;

				default: // case 5:
					r = v;
					g = p;
					b = q;
			}

			return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
		}

	</script>
}